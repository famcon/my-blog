---
title: 실행계획
date: "2023-06-03T12:00:00.000Z"
tags:
    - "RDBMS"
    - "MySQL"
---

실행계획은 요청한 SQL을 처리하기 전에 옵티마이저가 짠 계획입니다.
MySQL에선 `explain`을 해당 쿼리의 실행계획을 확인할 수 있습니다.

개발자는 옵티마이저의 계획을 보고 자신이 짠 쿼리가 최적화가 필요한지 미리 확인합니다.
또 슬로우쿼리 알림을 받으면 해당 쿼리를 수정하고 최적화가 되었는지 미리 확인할 수 있습니다.

`EXPLAIN` 명령어의 결과는 여러 컬럼을 가지며, 각 컬름이 무엇을 의미하는지 정확히 이해하는 것이 중요합니다.


## FORMAT

---

explain의 결과는 TREE 또는 JSON으로 확인할 수 있습니다.

TREE로 확인하면 순서를 보기 편한데요.

읽는 방법이 조금 헷갈릴 수 있습니다.

일단 읽는 기준은 

- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
- 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행

입니다.

```sql
(1)		 ->
(2)				->
(3)				->
(4)					->
(5)				->	 
```

위 Tree 형태 실행계획 결과에서 확인할 수 있는 순서는 2→ 4→ 3 → 5 → 1 입니다.

4번은 3번에 포함되어 있는 동작이고, 2번과 3번중에 2번이 먼저 실행됐기 때문에 2 -> 3 그리고 3번 내에 4번이 실행되는 순서입니다.




## 실행계획 컬럼

---

컬럼 종류는 id, select_type, table 등 많은데
최적화와 관련이 많은 3가지만 정리해보았습니다.

### 1. type

최적화에 있어서 가장 중요한 컬럼이 `type` 입니다.

MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지 나타냅니다.

- system
  - 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근방법입니다.
  - InnoDB에서는 나타나지 않습니다.
- const
  - 쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지고 았고 반드시 1건을 반환하는 쿼리의 처리방식입니다.
  - 다른 DBMS에서는 이를 `유니크 인덱스 스캔`이라고도 표현합니다.
- eq_ref
  - 여러 테이블이 조인되는 쿼리의 실행계획에서만 표시되며, 조인에서 처음 읽은 테이블의 컬럼값을 그 다음에 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용할 때 표시됩니다.
- ref
  - 조인의 순서와 관계없이 사용되고, 프라이머리 키나 유니크 키 제약조건 없이 동등 조건으로 검색될 때 사용합니다.
- fulltext
  - 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미합니다.
- ref_or_null
  - ref 접근 방법에서 null 비교가 추가된 형태입니다.
- unique subquery
  - WHERE 조건절에서 사용될 수 있는 IN 형태의 쿼리를 위한 접근 방법으로 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 사용됩니다.
- index_subquery
  - IN연산자의 특성상 IN(subquery) 또는 IN(상순 나열) 형태의 조건은 괄호안의 값 목록에서 중복된 값이 먼저 제거돼야 합니다. 
  - 서브 쿼리 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 index_subquery 접근 방법이 사용됩니다.
- range 
  - 인덱스 레인지 스캔 형태의 접근 방법입니다. 
  - 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미하는데 <, > , IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때 사용합니다.
- index_merge 
  - 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후, 결과를 병합하는 방식입니다. 

여기서 부턴 매우 비효율적인 스캔 방식입니다.

- index 
  - 인덱스 풀 스캔을 의미합니다.
- all 
  - 풀 테이블 스캔을 의미합니다.


### 2. key

key_len은 다중 컬럼으로 구성된 인덱스에서 몇개의 컬럼까지 사용했는지 알려줍니다.

예를 들어 인덱스로 사용된 컬럼타입이 utf8mb4를 사용하는 char(4)인 경우, 4*4(=16) 바이트가 표시됩니다.

### 3. Extra

Extra 역시 성능 최적화에 중요한 내용들이 표시됩니다.

주로 내부적인 처리 알고리즘에 대해 조금 더 깊이 있는 내용을 보여줍니다.

- const row not found 
  - const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 없으면 표시됩니다.
- distinct
  - 중복 행을 제거하는 데 사용됨을 나타냅니다.
- first_match
  - 조인에서 불필요한 행들을 모두 읽지 않고, 첫 번째 일치하는 행을 찾는 것만으로도 작업을 종료하는 경우에 사용됩니다.
- full_scan on NULL key 
  - 비교 타겟이 null인 경우 풀 테이블 스캔을 해야만 결과를 알수 있어 표시됩니다. 
  - not null 컬럼이거나 where절에 is not null을 붙이면 사라집니다.
- impossible 
  - having이나 where절의 조건을 만족하는 레코드가 없을 때 표시됩니다.
- using index 
  - 데이터 파일을 전혀 읽지 않고, 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 표시됩니다.
- using index condition 
  - 인덱스 컨디션 푸시다운 최적화를 사용하면 표시됩니다.


이렇게 실행계획의 포맷과 각 컬럼의 중요 값에 대해 정리해보았는데요.

다음에는 실제 슬로우 쿼리를 실행계획을 통해 최적화하는 글을 작성해보겠습니다.
오늘은 정리하는데에만 너무 많은 손가락을 써서 손목이 덜덜 떨려 더 이상 못쓰겠네요.
